## 1. MIPS 指令集架構 (ISA)
MIPS 指令集架構是一種精簡指令集（RISC），設計上強調簡單且規律性，以提升效能。

- **指令格式**：MIPS 主要有三種指令格式：
  - **R 格式**：適用於寄存器間操作，包含操作碼 (opcode)、來源寄存器 (rs, rt)、目標寄存器 (rd)、函數碼 (funct) 等欄位。
  - **I 格式**：用於立即數、分支和載入/存儲操作，包含操作碼、來源寄存器、目標寄存器以及偏移量/立即數。
  - **J 格式**：適用於跳躍指令，包含操作碼和目標地址欄位。

以下是 MIPS 指令集架構 (ISA) 中的 R、I、J 格式，以及性能指標、虛擬指令與組合指令、CPU 時間與性能分析的更詳細解說：

---
 
#### R 格式 (Register Format)
R 格式主要用於寄存器間操作，如算術運算和邏輯運算。

| 欄位名稱 | 位數 | 說明 |
| -------- | ---- | ---- |
| opcode   | 6    | 操作碼，指令類型的標識 |
| rs       | 5    | 第一個來源寄存器 |
| rt       | 5    | 第二個來源寄存器或目標寄存器 |
| rd       | 5    | 目標寄存器 |
| shamt    | 5    | 移位數量，用於移位指令，其餘指令中設定為 0 |
| funct    | 6    | 函數碼，指定指令的具體操作，如加法、減法等 |

- **常見指令**：
  - `add rd, rs, rt`：將寄存器 `rs` 和 `rt` 的值相加，結果儲存在 `rd`。
  - `sub rd, rs, rt`：將寄存器 `rs` 減去 `rt`，結果儲存在 `rd`。
  - `sll rd, rt, shamt`：將 `rt` 的值左移 `shamt` 位，結果儲存在 `rd`。

#### I 格式 (Immediate Format)
I 格式適用於涉及立即數的操作、分支指令和記憶體訪問（載入/存儲）指令。

| 欄位名稱 | 位數 | 說明 |
| -------- | ---- | ---- |
| opcode   | 6    | 操作碼 |
| rs       | 5    | 來源寄存器 |
| rt       | 5    | 目標寄存器或基址寄存器 |
| immediate| 16   | 立即數或偏移量 |

- **常見指令**：
  - `addi rt, rs, immediate`：將 `rs` 的值加上立即數 `immediate`，結果存儲在 `rt`。
  - `lw rt, offset(rs)`：從記憶體地址 `rs + offset` 中載入值至 `rt`。
  - `beq rs, rt, offset`：當 `rs` 和 `rt` 相等時，跳轉至 `PC + 4 + offset * 4` 的位置。

#### J 格式 (Jump Format)
J 格式主要用於跳躍指令，適合遠距離的無條件跳轉。

| 欄位名稱 | 位數 | 說明 |
| -------- | ---- | ---- |
| opcode   | 6    | 操作碼 |
| address  | 26   | 目標地址，透過 `PC` 的高 4 位和低位 26 位組合成 32 位目標地址 |

- **常見指令**：
  - `j target`：跳轉至指定的目標地址。
  - `jal target`：跳轉至目標地址並將返回地址存入 `$ra` 寄存器。

---

- **常見指令**：
  - **算術指令**：`add`, `sub`, `addi` 等。
  - **邏輯指令**：`and`, `or`, `xor`, `nor` 等。
  - **移位指令**：`sll`（左移位），`srl`（右移位）。
  - **分支指令**：`beq`（相等時分支），`bne`（不相等時分支），`j`（無條件跳躍），`jal`（跳躍並鏈接）。
  - **資料傳輸指令**：`lw`（載入字），`sw`（存儲字）。

- **指令組合與虛擬指令**：MIPS 缺少某些直接指令（例如 `blt`, `bge`），可以透過 `slt`, `bne`, `beq` 組合來模擬。例如，若要實現「小於則跳躍」，可以透過 `slt` 和 `bne` 的組合來達成。

## 2. 定址模式 (Addressing Modes)
定址模式指令操作數的來源。MIPS 定址模式的分類和使用情境如下：

  - **Register Addressing**：直接從寄存器中讀取操作數。
  - **Immediate Addressing**：立即數作為操作數（如 `addi`）。
  - **Base Addressing**：基址加偏移量，用於存取陣列或結構（如 `lw`, `sw`）。
  - **PC-Relative Addressing**：相對於 PC 的偏移量，通常在分支指令中使用（如 `beq`, `bne`）。
  - **Pseudo-direct Addressing**：直接跳轉的地址，適用於跳躍指令（如 `j`, `jal`）。

- **PC-Relative Addressing 與 Base Addressing 的區別**：
  - **PC-Relative** 基於當前指令位置的偏移，用於分支控制。
  - **Base Addressing** 基於基址寄存器和偏移量，用於資料存取。

---

以下是 MIPS 的定址模式 (Addressing Modes) 的詳細介紹，涵蓋了各種模式的工作原理、特點以及在不同指令中的應用。

---

MIPS 定址模式決定了指令如何訪問操作數（如數據或地址），適用於不同指令類型的數據存取需求。常見的 MIPS 定址模式有五種：Register Addressing、Immediate Addressing、Base Addressing、PC-Relative Addressing 和 Pseudo-direct Addressing。

#### 1. Register Addressing（寄存器定址）

- **說明**：直接從寄存器中獲取操作數。
- **格式**：操作數位於寄存器中，由寄存器名稱指定。
- **指令例子**：
  - `add $t0, $t1, $t2`：將寄存器 `$t1` 和 `$t2` 的值相加，結果存儲在 `$t0`。
  - `sub $s0, $s1, $s2`：將寄存器 `$s1` 減去 `$s2` 的值，結果存儲在 `$s0`。
- **特點**：Register Addressing 是 MIPS 中最常見的定址模式，寄存器訪問速度快，適合頻繁操作。

#### 2. Immediate Addressing（立即數定址）

- **說明**：操作數為指令中的一個常數（立即數），直接作為指令的一部分。
- **格式**：指令的 `immediate` 欄位存放立即數。
- **指令例子**：
  - `addi $t0, $t1, 10`：將 `$t1` 的值加上立即數 `10`，結果存入 `$t0`。
  - `ori $t1, $t2, 0xFF`：將 `$t2` 的值與立即數 `0xFF` 進行位元或操作，結果存入 `$t1`。
- **特點**：適用於小範圍常數的操作，避免記憶體讀取延遲；立即數位數為 16 位，範圍為 `-32768` 到 `32767`。

#### 3. Base Addressing（基址定址）

- **說明**：使用基址寄存器和偏移量來確定操作數的記憶體地址，適用於存取陣列或結構中的元素。
- **格式**：指令的 `rs` 欄位為基址寄存器，`immediate` 欄位為偏移量。
- **指令例子**：
  - `lw $t0, 4($s3)`：從基址寄存器 `$s3` 加上偏移量 `4` 的地址中載入數據至 `$t0`。
  - `sw $t1, 8($s4)`：將 `$t1` 的數據存入基址寄存器 `$s4` 加上偏移量 `8` 的地址中。
- **特點**：常用於陣列和資料結構的操作，可以通過偏移量訪問不同元素，偏移量是 16 位的立即數。

#### 4. PC-Relative Addressing（PC 相對定址）

- **說明**：通過 PC (程式計數器) 加上偏移量來確定目標地址，適用於分支指令。
- **格式**：分支指令的 `immediate` 欄位為偏移量，實際跳轉地址為 `PC + 4 + (offset × 4)`。
- **指令例子**：
  - `beq $t0, $t1, label`：如果 `$t0` 等於 `$t1`，則跳轉到 `PC + offset × 4` 的地址。
  - `bne $s0, $s1, label`：如果 `$s0` 不等於 `$s1`，則跳轉到 `PC + offset × 4` 的地址。
- **特點**：PC-Relative Addressing 適合短距離跳轉，偏移量以 16 位來表示，範圍為 `±32767` 個指令。這種定址模式提高了程序控制流的靈活性，特別適合迴圈或條件分支。

#### 5. Pseudo-direct Addressing（虛擬直接定址）

- **說明**：透過 J 格式的跳轉指令，使用 26 位的目標地址來確定跳轉的目標，適用於長距離無條件跳轉。
- **格式**：J 指令格式中的 `address` 欄位提供目標地址。
  - **目標地址計算**：以 `PC[31:28]` 作為高 4 位，26 位的 `address` 左移 2 位，形成 32 位的地址。
  - 結果地址為 `PC[31:28] | (address << 2)`。
- **指令例子**：
  - `j target`：跳轉到 `target` 的地址。
  - `jal target`：跳轉到 `target` 的地址並將返回地址存入 `$ra`。
- **特點**：目標地址可以達到 28 位寬（約 256 MB 的地址空間），適合程式中的遠距離跳轉，例如函數呼叫。

---

### 各定址模式的應用範例

- **算術與邏輯操作**：通常使用 Register Addressing 或 Immediate Addressing。例如，加法、減法、與或操作等。
- **資料載入/存儲**：常使用 Base Addressing，用於陣列或資料結構的操作。
- **分支操作**：通常使用 PC-Relative Addressing，適用於 if/else 條件控制流。
- **跳躍操作**：長距離跳轉使用 Pseudo-direct Addressing，適合函數呼叫和返回操作。

### 各定址模式的總結表

| 定址模式                | 操作數來源                            | 指令類型                 | 特點                                           |
|------------------------|--------------------------------------|--------------------------|------------------------------------------------|
| Register Addressing    | 寄存器                              | 算術、邏輯               | 速度快，適用於頻繁操作                         |
| Immediate Addressing   | 指令中的立即數                      | 算術、邏輯               | 效率高，適合小範圍常數操作                     |
| Base Addressing        | 基址寄存器 + 偏移量                  | 載入/存儲               | 適合陣列、結構操作，偏移量有 16 位             |
| PC-Relative Addressing | PC + 偏移量                         | 分支                     | 適合短距離跳轉，範圍有限                       |
| Pseudo-direct Addressing | 26 位地址 + PC 高 4 位              | 跳轉                     | 適合遠距離跳轉，地址空間可達 256 MB            |

---

### 定址模式的選擇策略

在 MIPS 中，不同定址模式根據指令的需求選擇最適合的方式。例如，算術運算和邏輯操作更適合 Register 和 Immediate Addressing，而分支控制則使用 PC-Relative Addressing，無條件跳轉指令使用 Pseudo-direct Addressing。這些選擇策略提升了指令執行的靈活性和性能。

## 3. 資料儲存的 Endian 模式
  - **Big Endian**：數據的高位元組存儲在低地址。
  - **Little Endian**：數據的低位元組存儲在低地址。
  - 示例：以 `0x12345678` 為例，在 Big Endian 格式下，按順序 `12 34 56 78` 存儲；在 Little Endian 格式下，則是 `78 56 34 12`。

---

以下是 MIPS 架構中關於資料儲存的 Endian 模式 (Endian Modes) 的詳細介紹，包含 Endian 的基本概念、各種模式的特點及其應用。

---

在電腦系統中，**Endian 模式**決定了多位元組資料在記憶體中的存放順序。這種模式影響了處理器在存取和解讀資料時的方式，是計算機組織與資料儲存的重要概念。常見的 Endian 模式有兩種：**Big Endian** 和 **Little Endian**。

#### 1. Big Endian

- **定義**：Big Endian 將多位元組數據的「高位元組」存放在記憶體的低位地址處，而「低位元組」存放在高位地址處。
- **特點**：資料的邏輯順序和物理儲存順序一致，便於人類閱讀和理解，因為高位元組在左、低位元組在右。
- **應用**：Big Endian 模式多用於網路協定（例如 IP 位址傳輸），因此又稱「網路位元組順序 (Network Byte Order)」。

  ##### Big Endian 的例子

  假設需要儲存 32 位元的 16 進位數 `0x12345678`，每 8 位元分為一個位元組 (Byte)，其在記憶體中的儲存順序為：

  ```
  地址        數據
  0x00      0x12  (高位元組)
  0x01      0x34
  0x02      0x56
  0x03      0x78  (低位元組)
  ```

  在此模式中，數據的高位 `0x12` 儲存在最低位的地址 `0x00`，低位 `0x78` 儲存在最高位地址 `0x03`。

#### 2. Little Endian

- **定義**：Little Endian 將多位元組數據的「低位元組」存放在記憶體的低位地址處，而「高位元組」存放在高位地址處。
- **特點**：這種模式便於硬體進行算術操作，因為最低有效位元組位於地址的起始位置，方便從低位開始逐位讀取。
- **應用**：Little Endian 主要用於 Intel 架構處理器（如 x86、x86-64）。

  ##### Little Endian 的例子

  同樣地，儲存 32 位元的 16 進位數 `0x12345678`，其在 Little Endian 模式下的記憶體儲存順序為：

  ```
  地址        數據
  0x00      0x78  (低位元組)
  0x01      0x56
  0x02      0x34
  0x03      0x12  (高位元組)
  ```

  在此模式中，數據的低位 `0x78` 儲存在最低位地址 `0x00`，高位 `0x12` 儲存在最高位地址 `0x03`。

#### 3. Big Endian 和 Little Endian 的比較

| 特性                 | Big Endian                     | Little Endian                    |
|----------------------|--------------------------------|----------------------------------|
| 高低位元組存放順序   | 高位元組在低地址，低位元組在高地址 | 低位元組在低地址，高位元組在高地址 |
| 儲存的可讀性         | 邏輯順序與物理順序一致，便於理解  | 便於硬體進行算術操作              |
| 應用範疇             | 網路協定、Motorola 處理器       | Intel 處理器（x86 架構）          |

#### 4. Endian 模式的應用場景

- **跨平台數據傳輸**：在不同架構之間進行資料傳輸時（如 Intel 和 ARM 系統），需要處理 Endian 的轉換，否則會導致數據解讀錯誤。
- **網路協定**：因為 Big Endian 是網路標準格式（例如 TCP/IP 協定），所以在進行網路傳輸時，常需將資料轉換為 Big Endian。
- **編碼和解碼**：數據編碼和解碼過程中，處理器根據自身的 Endian 模式解釋儲存的數據，因而在解碼時需了解數據的儲存順序。

#### 5. 實際應用中的例子

- **網路數據傳輸中的 Endian**：在網路中，假設傳輸一個 16 進位的整數 `0x1234`，Big Endian 傳輸順序是 `0x12 0x34`，而 Little Endian 傳輸順序是 `0x34 0x12`。
- **跨平台程式設計中的考慮**：例如，在 x86 和 ARM 平台上編寫 C 程式時，若涉及二進位數據操作或直接的位元組操作，需要明確指定 Endian 模式，或使用標準庫中的 Endian 轉換函數（如 `htonl()` 和 `ntohl()`）來處理。

#### 6. 如何在程式中處理 Endian 模式

在程式設計中，為了確保資料的一致性，通常會採取以下方法：

- **轉換函數**：利用標準函數如 `htonl()`（Host to Network Long）、`ntohl()`（Network to Host Long）來確保數據以 Big Endian 格式傳輸。
- **手動轉換**：根據需要，手動交換數據的位元組順序。例如，對一個 32 位元的整數進行位元組交換：
  ```c
  uint32_t swap_uint32(uint32_t val) {
      return ((val << 24) & 0xFF000000) |
             ((val << 8) & 0x00FF0000) |
             ((val >> 8) & 0x0000FF00) |
             ((val >> 24) & 0x000000FF);
  }
  ```

---

### 總結

Endian 模式決定了多位元組資料在記憶體中的儲存順序。Big Endian 將高位元組存放在低地址，常見於網路協定；Little Endian 將低位元組存放在低地址，常見於 Intel 架構。瞭解並正確處理 Endian 模式對於跨平台程式設計和網路傳輸至關重要。

---

## 4. 跳躍指令 (jr 與 jal)
  - **jr (jump register)**：從寄存器中取出地址並跳轉，用於子程序返回。
  - **jal (jump and link)**：跳轉至指定地址，並將返回地址保存在 `$ra` 中。用於調用子程序，方便返回時使用 `jr $ra`。

## 5. 暫存器搬移
MIPS 沒有 `move` 指令，可以使用 `add` 指令與 `$zero` 實現寄存器搬移。例如，將 `$s1` 搬移至 `$t2` 可表達為 `add $t2, $s1, $zero`。

## 6. Pipeline 與執行階段
MIPS 處理器透過流水線 (Pipeline) 技術來提高指令吞吐量，將指令分為以下五個執行階段：

  - **IF (Instruction Fetch)**：從記憶體中取出指令。
  - **ID (Instruction Decode)**：解碼指令並讀取寄存器數據。
  - **EX (Execute)**：ALU 執行算術或邏輯運算。
  - **MEM (Memory Access)**：進行記憶體訪問，適用於載入/存儲指令。
  - **WB (Write Back)**：將結果寫回寄存器。

---

在現代處理器中，Pipeline 是一種提高指令執行效率的技術，將指令分解為多個階段並行執行。每個指令執行的一部分與其他指令的部分操作同時進行，這樣能夠在單位時間內完成更多的指令處理，提高處理器的吞吐量。

#### Pipeline 的五個執行階段 (Pipeline Stages)

MIPS 使用五段流水線架構來分解指令執行的過程，將每條指令的執行分成以下五個階段：

1. **IF (Instruction Fetch) - 指令取出**
   - **目的**：從指令記憶體中取出當前指令。
   - **操作**：
     - 使用程式計數器 (PC) 讀取當前指令地址。
     - 指令取出後，PC 加 4 以指向下一條指令。
   - **輸出**：取出的指令傳遞到下一階段 (ID)。
   
2. **ID (Instruction Decode) - 指令解碼與寄存器讀取**
   - **目的**：解碼指令並讀取所需的寄存器值。
   - **操作**：
     - 解碼取出的指令，確定指令的操作類型和所需的操作數。
     - 從寄存器檔案中讀取指令中指定的來源寄存器值（如 `rs` 和 `rt`）。
     - 若為分支指令，計算分支目標地址。
   - **輸出**：解碼後的控制訊號和讀取的寄存器值傳遞到下一階段 (EX)。

3. **EX (Execute) - 執行或地址計算**
   - **目的**：執行 ALU 運算或計算存取記憶體的地址。
   - **操作**：
     - 算術和邏輯指令：由 ALU 執行指定的算術或邏輯操作。
     - 分支指令：計算目標地址並判斷分支條件是否成立。
     - 記憶體存取指令：根據基址寄存器和偏移量計算記憶體地址。
   - **輸出**：ALU 的計算結果或記憶體地址傳遞到下一階段 (MEM)。

4. **MEM (Memory Access) - 記憶體存取**
   - **目的**：對資料記憶體進行讀取或寫入。
   - **操作**：
     - 載入指令 (`lw`)：從記憶體地址讀取數據並存入暫存器。
     - 存儲指令 (`sw`)：將暫存器中的數據寫入指定的記憶體地址。
     - 算術和邏輯指令：跳過此階段，直接傳遞到下一階段 (WB)。
   - **輸出**：讀取到的數據或操作結果傳遞到下一階段 (WB)。

5. **WB (Write Back) - 寫回**
   - **目的**：將計算結果或從記憶體載入的數據寫回寄存器。
   - **操作**：
     - 將 MEM 階段傳遞的數據或運算結果寫回指定的目的寄存器。
   - **輸出**：執行完成，寄存器更新。

#### Pipeline 的優勢

- **增加吞吐量**：每個時鐘周期內可處理多個指令的不同階段，單位時間內完成的指令數增加。
- **縮短指令執行時間**：透過分解執行過程，將指令以並行方式進行處理，使得總的指令執行時間縮短。
- **高效利用硬體資源**：在多個指令同時執行的情況下，能夠更充分地利用 ALU、記憶體等硬體資源。

#### Pipeline 的挑戰與 Hazard 處理

儘管 Pipeline 技術提高了效率，但在執行過程中可能會遇到不同類型的 Hazard（危障），主要包括結構性危障、資料危障和控制危障：

1. **結構性危障 (Structural Hazard)**：
   - 當 Pipeline 中的多條指令同時需要使用相同的硬體資源（如 ALU 或記憶體）時，就會發生結構性危障。
   - **解決方法**：增加硬體資源的複本，例如設置獨立的指令記憶體和數據記憶體，以便同時進行指令取出和數據存取。

2. **資料危障 (Data Hazard)**：
   - 當一條指令依賴於前一條指令的結果，但該結果尚未準備好時，會發生資料危障。例如，若前一條指令剛將計算結果存入寄存器，而下一條指令立即讀取該寄存器。
   - **解決方法**：利用**前饋 (Forwarding)** 技術將 ALU 的運算結果直接傳遞給下一條指令，無需等待寫回寄存器；或插入 NOP 指令（延遲槽），讓處理器等待結果準備完成。

3. **控制危障 (Control Hazard)**：
   - 分支指令（如 `beq`、`bne`）會改變控制流，導致後續指令的執行順序不確定，從而引發控制危障。
   - **解決方法**：使用**分支預測**技術來預測分支結果，若預測正確則可繼續執行，若預測錯誤則執行 Pipeline Flush（清空流水線）。

#### Pipeline 示例：五階段流水線執行過程

假設程式包含三條指令 A、B 和 C，並按照流水線執行：

| 時鐘周期 | 階段1 (IF) | 階段2 (ID) | 階段3 (EX) | 階段4 (MEM) | 階段5 (WB) |
|----------|------------|------------|------------|-------------|------------|
| 1        | A          |            |            |             |            |
| 2        | B          | A          |            |             |            |
| 3        | C          | B          | A          |             |            |
| 4        |            | C          | B          | A           |            |
| 5        |            |            | C          | B           | A          |
| 6        |            |            |            | C           | B          |
| 7        |            |            |            |             | C          |

在這個五階段流水線示例中，指令 A 先完成執行並寫回，接著是指令 B 和 C。這樣，每個時鐘周期內各階段都在處理不同的指令，實現了指令的並行處理。

---

### 總結

MIPS 的 Pipeline 結構分為五個執行階段：IF、ID、EX、MEM、WB。每個階段負責指令執行的不同部分，通過流水線技術可以實現指令並行執行，從而提升處理器的指令吞吐量。然而，Pipeline 也帶來了 Hazard 挑戰，需要利用前饋和分支預測等技術來處理，以維持高效的執行效率。

---

## 7. Pipeline Hazards (流水線危障)
流水線中的指令間有依賴關係，會導致三種危障：

  - **結構性危障 (Structural Hazard)**：多條指令需要相同的硬體資源，導致衝突。
  - **資料危障 (Data Hazard)**：指令間存在數據依賴，當指令需要依賴前一指令的結果時會發生。
    - **解決方法**：透過前饋 (Forwarding) 或插入 NOP 指令來解決。
  - **控制危障 (Control Hazard)**：分支指令改變控制流，導致不確定應執行哪條指令。
    - **解決方法**：透過分支預測技術（如靜態預測和動態預測）來減少控制危障的影響。
---

以下是 MIPS Pipeline 中的 Hazard（危障）詳細介紹，包括 Hazard 的種類、發生原因及其解決方案。

---

Pipeline Hazard 指的是指令在流水線中並行執行時，由於指令間存在依賴關係或資源衝突，導致流水線無法正常運行的情況。Pipeline Hazard 可分為三類：結構性危障、資料危障和控制危障。

#### 1. 結構性危障 (Structural Hazard)

- **原因**：當流水線中多條指令同時需要使用相同的硬體資源（例如 ALU、記憶體）時，就會發生結構性危障。由於硬體資源不足，某些指令必須等待其他指令釋放資源，這樣會減慢流水線的執行效率。
- **示例**：假設處理器只有一個記憶體模組，若一條指令在 MEM 階段讀取數據時，同時另一條指令在 IF 階段嘗試取指令，則會發生衝突。
- **解決方法**：
  - 增加資源複本：在 MIPS 中，通過指令記憶體和數據記憶體分開來消除結構性危障，使得取指令和數據存取可以同時進行。
  - 超純量架構：多個功能單元允許更多指令在同一時鐘周期內執行，避免資源衝突。

#### 2. 資料危障 (Data Hazard)

- **原因**：資料危障發生於指令之間存在數據依賴關係。例如，一條指令的結果是下一條指令的輸入，而結果尚未準備好。資料危障分為以下三種類型：
  - **RAW (Read After Write)**：讀取操作依賴於前一指令的寫入結果。
  - **WAR (Write After Read)**：寫入操作依賴於前一指令的讀取結果。
  - **WAW (Write After Write)**：寫入操作依賴於前一指令的寫入結果。
  
  在 MIPS Pipeline 中，RAW 資料危障最為常見。

- **示例**：
  ```assembly
  add $s0, $t0, $t1    # 指令 1：$s0 = $t0 + $t1
  sub $t2, $s0, $t3    # 指令 2：需要 $s0 的值
  ```
  在此例中，`sub` 指令需要使用 `add` 指令的結果 `$s0`，但在 `add` 寫回 `$s0` 之前，`sub` 可能已經開始執行，導致錯誤結果。

- **解決方法**：
  - **前饋 (Forwarding/Bypassing)**：當 ALU 計算結果尚未寫回寄存器，但後續指令需要此結果時，將 ALU 的輸出直接轉發給需要的指令，無需等待寫回。例如，在 EX 階段的計算結果可以直接傳遞給下一條指令的 EX 階段。
  - **插入 NOP（空操作）**：插入一個 NOP（No Operation）指令讓流水線停滯一個時鐘周期，等待前一指令執行完畢，這種方法簡單但會降低效率。
  - **編譯器優化**：編譯器可以對指令進行重新排序，以降低資料危障的發生。例如，可以將與結果無關的指令插入依賴指令之間。

#### 3. 控制危障 (Control Hazard)

- **原因**：控制危障發生於分支指令和跳躍指令，當這些指令改變控制流時，後續指令的執行路徑尚未確定，導致流水線出現錯誤或停滯。例如，當處理器尚未決定分支條件是否成立時，不確定接下來應該執行哪一條指令。
- **示例**：
  ```assembly
  beq $t0, $t1, label  # 若 $t0 == $t1，則跳轉至 label
  ```
  在執行 `beq` 指令時，分支是否成立尚未確定，處理器無法確定下一步執行的是 `label` 指令還是順序下一條指令。

- **解決方法**：
  - **分支預測 (Branch Prediction)**：根據過去的分支行為進行預測，如果預測正確則流水線正常執行，若預測錯誤則進行流水線清空 (Pipeline Flush)。
    - **靜態分支預測**：固定策略，如「分支不成立」（假設分支不跳轉）或根據指令位置決定。
    - **動態分支預測**：根據實際運行時記錄的分支歷史，預測分支是否成立。
  - **延遲槽 (Delay Slot)**：將下一條指令放置在分支指令之後的延遲槽中，即使分支跳轉執行，延遲槽中的指令也能正常執行。這是一種特殊的編譯器優化技術。
  - **Pipeline Flush**：如果分支預測錯誤，清空流水線中已經取出的指令並重新加載正確的指令。這種方法簡單但會影響性能。

#### 各類 Hazard 的處理技術總結

| Hazard 類型   | 發生原因                                          | 解決方法                                   |
|---------------|---------------------------------------------------|--------------------------------------------|
| 結構性危障    | 多條指令同時需要相同的硬體資源                     | 增加資源複本（如分離指令和數據記憶體）     |
| 資料危障      | 指令之間存在數據依賴 (RAW, WAR, WAW)              | 前饋技術、插入 NOP、編譯器優化             |
| 控制危障      | 分支指令或跳躍指令導致控制流不確定                 | 分支預測、延遲槽、Pipeline Flush           |

---

### Pipeline Hazard 示例：三條指令的執行過程

假設有三條指令需要依次執行：

```assembly
1. lw $t1, 0($t0)     # 指令 1：載入 $t1
2. add $t2, $t1, $t3  # 指令 2：使用 $t1
3. sub $t4, $t2, $t5  # 指令 3：使用 $t2
```

在此例中，由於 `add` 和 `sub` 都依賴前一指令的計算結果，會發生資料危障。可以通過前饋機制在指令之間傳遞 ALU 的結果，來解決這種資料危障問題。

### 總結

Pipeline Hazard 是處理器並行執行中的重要挑戰，包括結構性危障、資料危障和控制危障。透過硬體（如前饋和分支預測）和編譯器優化技術（如延遲槽和指令重排）可以有效解決這些問題，使得處理器能夠維持高效運行。

## 8. 前饋與分支預測
  - **前饋 (Forwarding)**：允許 ALU 的運算結果在寫回寄存器前即被使用，以減少資料危障帶來的延遲。
  - **分支預測 (Branch Prediction)**：
    - **靜態預測**：預測分支不成立（如跳過分支指令）。
    - **動態預測**：基於過去的分支結果，儲存分支歷史並根據歷史預測未來。

## 9. 性能指標與計算
  - **CPI (Cycles Per Instruction)**：平均每條指令所需的時鐘週期數，用於評估指令執行效率。
  - **MIPS (Million Instructions Per Second)**：指令執行速度，MIPS 值越高代表效能越好。
  - **CPU 執行時間公式**：
    
     $$ CPU 時間 = \frac{指令數量 \times CPI}{時鐘頻率} $$
    
  - **Rpeak 計算浮點運算單元數量 (FPU)**：使用超級計算機中的核心數量、核心頻率和理論峰值運算速度 (Rpeak) 來估算浮點運算單元。

---

在評估 CPU 性能時，MIPS 使用以下幾個關鍵指標：

#### 1. CPI (Cycles Per Instruction)
CPI 是指平均每條指令需要的時鐘週期數，越低的 CPI 表示每條指令所需的時間越少，性能越高。

- **計算公式**：
  
 $$ CPI = \frac{總時鐘週期}{指令數量} $$
 
- CPI 的影響因素包括指令組成、指令執行結構（如 Pipeline）、記憶體速度等。

#### 2. MIPS (Million Instructions Per Second)
MIPS 是每秒執行的百萬條指令數，表示 CPU 執行速度。MIPS 的值越高，代表 CPU 性能越好。

- **計算公式**：
  
 $$ MIPS = \frac{時鐘頻率（MHz）}{CPI} $$
  
- **例子**：若 CPU 時鐘頻率為 2 GHz（2000 MHz），CPI 為 2，則 MIPS 值為

 $$ \frac{2000}{2} = 1000 MIPS。 $$

#### 3. CPU 執行時間
CPU 的執行時間是衡量一個程式執行時間的指標，公式為：

$$ CPU 時間 = 指令數 \times CPI \times 時鐘週期時間 $$

其中，時鐘週期時間等於
 
 $$ \frac{1}{\text{時鐘頻率}} $$

## 10. 虛擬指令與組合指令
  - MIPS 中，某些虛擬指令 (Pseudo Instructions) 並不存在，但可透過其他指令組合來實現。例如 `bge` 可以用 `slt` 和 `bne` 指令來實現。
  - 常見組合：
    - `move $t2, $s1` 可以替換為 `add $t2, $s1, $zero`。
    - `bge $s1, $s2, L` 可以替換為 `slt $t0, $s1, $s2` 和 `beq $t0, $zero, L`。

---

MIPS 的一些指令需要透過其他指令組合來實現，這些指令被稱為「虛擬指令 (Pseudo Instructions)」。虛擬指令並不是真正的硬體指令，而是由編譯器將其轉換為硬體可執行的基本指令組合。

#### 常見虛擬指令和組合
- **移動指令 (move)**：MIPS 沒有 `move` 指令，通常使用 `add` 指令和 `$zero` 寄存器來實現。例如，將 `$s1` 移至 `$t2` 可寫成：
  ```assembly
  add $t2, $s1, $zero
  ```
- **大於等於條件跳躍 (bge)**：MIPS 沒有 `bge` 指令，可以用 `slt` 和 `beq` 組合來模擬。例如，要達成 `bge $s1, $s2, L`，可以寫成：
  ```assembly
  slt $t0, $s2, $s1
  beq $t0, $zero, L
  ```
- **小於條件跳躍 (blt)**：`blt` 指令可用 `slt` 和 `bne` 實現。例如：
  ```assembly
  slt $t0, $s1, $s2
  bne $t0, $zero, L
  ```


## 11. CPU 時間與性能分析
  - **時鐘週期 (Clock Cycle)**：每秒的時鐘信號次數，決定 CPU 指令執行速度。
  - **CPI 與時鐘週期時間的關係**：時鐘週期越短、CPI 越低則性能越高。使用多階段 Pipeline 時，CPI 會低於單階段 Pipeline。
  - **執行時間與 MIPS 評估**：CPU 時間的增減與 MIPS 數值的變化可以有效指標化 CPU 的性能差異。

---

#### 1. CPU 時間計算
CPU 的執行時間可以透過指令數量、CPI 和時鐘頻率來計算：

$$ CPU 時間 = \frac{{指令數量} \times {CPI}}{時鐘頻率} $$

其中：
- **指令數量**：程式中需要執行的指令數量。
- **CPI**：每條指令平均需要的時鐘週期數。
- **時鐘頻率**：CPU 每秒運行的時鐘週期數，通常以 GHz 為單位。

#### 2. CPU 性能比較
若要比較兩個 CPU 的效能，可以使用執行時間公式來進行。假設有兩台 CPU，分別為 CPU A 和 CPU B：

- **CPU A**：時鐘週期時間為 500 ns，CPI 為 1.5。
- **CPU B**：時鐘週期時間為 400 ns，CPI 為 1.8。

比較方式：
1. 計算每台 CPU 的執行時間：
   - **CPU A** 的執行時間：
     
$$ 500 \times 1.5 = 750 ns $$
   
   - **CPU B** 的執行時間：

$$ 400 \times 1.8 = 720 $ ns $$
   
3. 比較兩者：
   - **CPU B 較快**，其性能是CPU A 的
     
$$ \frac{750}{720} \approx 1.042 倍 $$

#### 3. IPC (Instructions Per Cycle)
IPC 是指每個時鐘週期內完成的指令數量，可透過以下公式計算：

$$ IPC = \frac{1}{CPI} $$

IPC 值越高，CPU 的指令吞吐量越

高。現代 CPU 通常會採用多重流水線技術來提升 IPC 值，以增加單位時間內的指令完成數。

#### 4. 系統效能瓶頸與改善
影響 CPU 效能的因素還包括記憶體存取延遲、分支預測準確性和 Pipeline 停滯現象等。常見的改善方法包括：

- 增加前饋 (Forwarding) 機制，解決資料危障。
- 使用分支預測來降低控制危障的影響。
- 引入多重 Pipeline 或超純量結構來提高 IPC。

---

這些筆記涵蓋了 MIPS 指令集的各個面向，從基本的指令格式、定址模式到 Pipeline 運作及危障處理，並詳細說明了常見的組合指令

及性能評估方法。這樣的筆記不僅可以作為考試的準備，也能幫助更深入地理解 MIPS 架構。

---

# 計算機組織筆記

---

## **1. Pipeline, Superpipeline, Superscalar 的差異**

### **Pipeline（管線化）**
- **概念**：將指令執行過程分為多個階段（如取指令、解碼、執行等），不同指令可同時在不同階段執行。
- **優點**：提升 CPU 吞吐量，增加系統效率，減少每個指令的總處理時間。
- **應用**：常見於現代處理器的基本設計中，用於提高指令執行的平行度。

### **Superpipeline（超管線化）**
- **概念**：進一步將每個管線階段細分為更小的子階段，使每個階段的處理時間更短。
- **特點**：每個時鐘週期內可以執行更多的操作，但需要額外的硬體資源來解決資料相依性問題。
- **挑戰**：更高的頻率和細化的階段設計對時鐘精度和同步性要求更高。

### **Superscalar（超純量）**
- **概念**：使用多個執行單元，允許多條指令同時進入管線並行執行。
- **優點**：顯著提高指令平行度和整體性能，適合執行大量無依賴關係的指令。
- **挑戰**：需要複雜的指令排程和資源分配機制來最大化硬體使用率。

---

## **2. Memory Hierarchy（記憶體層次）與快取映射方式**

### **記憶體層次**
- **結構**：
  1. **寄存器**：速度最快，容量最小，直接內建於 CPU。
  2. **快取（Cache）**：由 SRAM 製成，分為 L1（最快）、L2 和 L3（容量最大，速度稍慢）。
  3. **主記憶體（Main Memory）**：使用 DRAM 製成，容量大，但速度較慢。
  4. **二級存儲（Secondary Storage）**：硬碟或 SSD，容量最大但速度最慢。
- **區域性原理**：
  - **時間區域性**：最近使用的資料可能很快再次被訪問，例如迴圈中的變數。
  - **空間區域性**：最近訪問資料附近的資料可能被使用，例如陣列中的連續元素。
- **性能影響**：合理的記憶體層次設計可以有效降低平均存取延遲，提升系統性能。

### **映射方式**
1. **Direct Mapped Cache（直接映射）**
   - **結構**：每個記憶體區塊只能映射到快取的特定位址。
   - **優點**：實現簡單，訪問速度快。
   - **缺點**：衝突未命中率高，特別是當多個區塊映射到同一行時。
2. **Set Associative Mapping（組關聯映射）**
   - **結構**：將快取分組，每組內有多行，記憶體區塊可映射到組內任一行。
   - **優點**：平衡了 Direct Mapping 的簡單性和 Fully Associative Mapping 的靈活性。
   - **應用**：常見於現代處理器的 L2 和 L3 快取設計中。
3. **Fully Associative Mapping（完全關聯映射）**
   - **結構**：記憶體區塊可映射到快取中任意行。
   - **優點**：完全消除了衝突未命中。
   - **缺點**：硬體實現複雜，搜尋成本高。

---

## **3. RAID 技術**

### **RAID 0（分條模式）**
- **功能**：將資料分條存儲於多顆硬碟，提供高讀寫性能。
- **最低硬碟數**：2。
- **優點**：性能提升顯著，特別適合需要高吞吐量的應用場景。
- **缺點**：無冗餘，任一硬碟故障將導致所有資料損失。
- **圖解**：
  ```plaintext
  資料 A → 硬碟 1
  資料 B → 硬碟 2
  資料 C → 硬碟 1
  資料 D → 硬碟 2
  ```

### **RAID 1（鏡像模式）**
- **功能**：將資料鏡像到兩顆或多顆硬碟，提供高可靠性。
- **最低硬碟數**：2。
- **優點**：具備故障容忍能力，任一硬碟損壞不影響數據可用性。
- **缺點**：存儲效率低（50%）。
- **圖解**：
  ```plaintext
  資料 A → 硬碟 1
           → 硬碟 2 (鏡像)
  ```

### **RAID 10（鏡像分條）**
- **功能**：結合 RAID 1 和 RAID 0，先鏡像後分條，提供高性能與高可靠性。
- **最低硬碟數**：4。
- **優點**：容許每組中一顆硬碟故障，讀寫性能出色。
- **缺點**：成本高，存儲效率僅為 50%。
- **圖解**：
  ```plaintext
  資料 A → 硬碟 1 (鏡像組 1)
           → 硬碟 2 (鏡像組 1)
  資料 B → 硬碟 3 (鏡像組 2)
           → 硬碟 4 (鏡像組 2)
  ```

### **RAID 50（RAID 5+0）**
- **功能**：結合 RAID 5 和 RAID 0，提供分散奇偶校驗與分條的雙重優勢。
- **最低硬碟數**：6。
- **優點**：具備高容錯能力和性能，奇偶校驗分散存放於所有硬碟，存儲效率高。
- **缺點**：硬體實現複雜，寫入性能略低於 RAID 0。
- **圖解**：
  ```plaintext
  RAID 5 組 1:
  資料 A → 硬碟 1
  資料 B → 硬碟 2
  奇偶校驗 → 硬碟 3

  RAID 5 組 2:
  資料 C → 硬碟 4
  資料 D → 硬碟 5
  奇偶校驗 → 硬碟 6
  ```

---

## **4. Cache Memory (SRAM) 與 RAM (DRAM) 的比較**

| 特性          | Cache Memory (SRAM)            | RAM (DRAM)                   |
|---------------|--------------------------------|------------------------------|
| **技術**      | 靜態隨機存取（SRAM）           | 動態隨機存取（DRAM）         |
| **成本**      | 高                             | 低                           |
| **速度**      | 非常快，接近 CPU 時鐘速度      | 快，但遠慢於 SRAM            |
| **容量**      | 小（KB~MB 級）                 | 大（GB 級）                  |
| **應用**      | CPU 快取（L1、L2、L3）         | 主記憶體                     |
| **刷新需求**  | 無需刷新                       | 需要定期刷新以保持數據完整性 |

---

## **5. DMA（Direct Memory Access，直接記憶體存取）**

### **主要元件**
1. **地址寄存器（Address Register）**：儲存目標地址，指示資料的來源和目的地。
2. **計數寄存器（Count Register）**：記錄剩餘的傳輸字元數量，減少到 0 時表示傳輸完成。
3. **控制寄存器（Control Register）**：設定 DMA 操作的模式，如讀取或寫入方向。
4. **資料緩衝器（Data Buffer）**：暫存傳輸過程中的資料，確保資料連續性。
5. **匯流排仲裁器（Bus Arbiter）**：協調 DMA 與 CPU 的匯流排使用權，避免資源衝突。

### **主要功能**
1. 減少 CPU 負擔：DMA 控制器直接處理記憶體與 I/O 裝置間的資料傳輸，釋放 CPU 資源。
2. 高效資料傳輸：消除 CPU 參與傳輸所需的額外時鐘週期。
3. 支援多通道傳輸：允許多個 I/O 裝置同時傳輸資料，提升系統並行能力。

### **操作步驟**
1. **CPU 配置 DMA 控制器**：設定源地址、目標地址和傳輸數據量。
2. **I/O 裝置發送請求**：通知 DMA 控制器開始數據傳輸。
3. **DMA 獲取匯流排控制權**：通過匯流排仲裁器獲取存取權限。
4. **執行資料傳輸**：DMA 控制器在記憶體與 I/O 裝置間移動數據。
5. **傳輸完成後通知 CPU**：通過中斷機制告知 CPU 傳輸結束。
6. **恢復匯流排控制權**：將控制權交還給 CPU，恢復正常操作。

---

## **6. 硬碟平均存取時間計算公式**

- **條件**：
  - **搜尋時間（Seek Time）**：硬碟讀寫頭定位到目標位置所需時間。
  - **平均旋轉延遲（Rotational Latency）**：磁碟旋轉到目標扇區所需時間，約為半圈時間。
  - **資料傳輸時間（Data Transfer Time）**：從扇區中讀取或寫入資料所需時間。

- **公式**：
  平均存取時間 = 搜尋時間 + 平均旋轉延遲 + 資料傳輸時間。

- **範例**：
  假設搜尋時間為 2ms，平均旋轉延遲為 2ms，資料傳輸時間為 1ms，則平均存取時間為：
  
  ```plaintext
  平均存取時間 = 2ms + 2ms + 1ms = 5ms
  ```

---


